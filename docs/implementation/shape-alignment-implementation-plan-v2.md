# Shapeæ•´åˆ—æ©Ÿèƒ½å®Ÿè£…è¨ˆç”»æ›¸ï¼ˆæ”¹è¨‚ç‰ˆv2ï¼‰

## æ”¹è¨‚å±¥æ­´
- 2025-09-15: å®Ÿè£…å¤±æ•—ã®åŸå› åˆ†æã‚’è¸ã¾ãˆãŸå¤§å¹…æ”¹è¨‚

## æ¦‚è¦
uSketchã«ShapeåŒå£«ã®æ•´åˆ—æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã¾ã™ã€‚éå»ã®å®Ÿè£…å¤±æ•—ã®åŸå› åˆ†æã«åŸºã¥ãã€**ç¢ºå®Ÿã«å‹•ä½œã™ã‚‹æœ€å°é™ã®å®Ÿè£…ã‹ã‚‰æ®µéšçš„ã«æ©Ÿèƒ½ã‚’æ‹¡å¼µ**ã™ã‚‹æ–¹é‡ã«è»¢æ›ã—ã¾ã—ãŸã€‚

## âš ï¸ éå»ã®å®Ÿè£…å¤±æ•—ã®åŸå› åˆ†æ

### æ ¹æœ¬åŸå› 
1. **SnapEngineãŒå®Œå…¨ã«ç©ºå®Ÿè£…** - æ•´åˆ—è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ãŒå­˜åœ¨ã—ãªã„ï¼ˆ`return position`ã®ã¿ï¼‰
2. **XStateã‚¢ã‚¯ã‚¿ãƒ¼é€šä¿¡ã®æ–­çµ¶** - `UPDATE_POSITION`ã‚¤ãƒ™ãƒ³ãƒˆã®é€ä¿¡ã‚³ãƒ¼ãƒ‰ãŒå­˜åœ¨ã—ãªã„
3. **WhiteboardStoreã«æ•´åˆ—æ©Ÿèƒ½ãŒæ¬ è½** - æ•´åˆ—ç”¨ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¨çŠ¶æ…‹ãŒæœªå®šç¾©
4. **UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ä¸åœ¨** - æ•´åˆ—æ“ä½œã®ãŸã‚ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒå­˜åœ¨ã—ãªã„
5. **ã‚¤ãƒ™ãƒ³ãƒˆãƒ•ãƒ­ãƒ¼ã®è¨­è¨ˆä¸å‚™** - å„å±¤ã§ã®å‡¦ç†ãŒé€£æºã—ã¦ã„ãªã„

### å¤±æ•—ã‚’é˜²ããŸã‚ã®å¯¾ç­–
- **æ®µéšçš„ãªå®Ÿè£…ã¨æ¤œè¨¼** - å„ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã«å‹•ä½œç¢ºèªã‚’å¾¹åº•
- **æœ€å°é™ã®å‹•ä½œã™ã‚‹å®Ÿè£…ã‹ã‚‰é–‹å§‹** - è¤‡é›‘ãªæ©Ÿèƒ½ã¯å¾Œå›ã—
- **æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã¨ã®çµ±åˆã‚’é‡è¦–** - æ–°è¦å®Ÿè£…ã‚ˆã‚Šæ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã®æ‹¡å¼µã‚’å„ªå…ˆ

## ğŸ¯ æ–°ã—ã„å®Ÿè£…æˆ¦ç•¥

### Phase 0: å³åº§ã«å‹•ä½œã™ã‚‹æœ€å°å®Ÿè£…ï¼ˆMVPï¼‰
**ç›®æ¨™**: ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã§é¸æŠä¸­ã®Shapeã‚’æ•´åˆ—ã§ãã‚‹æœ€å°æ©Ÿèƒ½

### Phase 1: åŸºæœ¬æ©Ÿèƒ½ã®å®Ÿè£…
**ç›®æ¨™**: SnapEngineã‚’å®Ÿè£…ã—ã€ãƒ‰ãƒ©ãƒƒã‚°æ™‚ã®ã‚¹ãƒŠãƒƒãƒ—ã‚’æœ‰åŠ¹åŒ–

### Phase 2: UIçµ±åˆ
**ç›®æ¨™**: æ•´åˆ—ãƒœã‚¿ãƒ³ã¨ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’è¿½åŠ 

## ğŸ“ è©³ç´°å®Ÿè£…è¨ˆç”»

### Phase 0: MVPå®Ÿè£…ï¼ˆ1æ—¥ï¼‰

#### 0.1 SelectToolã«æ•´åˆ—ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 

```typescript
// packages/tools/src/tools/select-tool.ts

// ã‚¤ãƒ™ãƒ³ãƒˆå®šç¾©ã‚’è¿½åŠ 
export type SelectToolEvent = 
  // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆ...
  | { type: "ALIGN_LEFT" }
  | { type: "ALIGN_CENTER_H" }
  | { type: "ALIGN_RIGHT" }
  | { type: "ALIGN_TOP" }
  | { type: "ALIGN_CENTER_V" }
  | { type: "ALIGN_BOTTOM" };

// selectedçŠ¶æ…‹ã«æ•´åˆ—å‡¦ç†ã‚’è¿½åŠ 
selected: {
  on: {
    // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆ...
    ALIGN_LEFT: {
      guard: ({ context }) => context.selectedIds.size > 1,
      actions: 'alignShapesLeft'
    },
    ALIGN_CENTER_H: {
      guard: ({ context }) => context.selectedIds.size > 1,
      actions: 'alignShapesCenterHorizontal'
    },
    // ä»–ã®æ•´åˆ—ã‚¤ãƒ™ãƒ³ãƒˆã‚‚åŒæ§˜...
  }
}

// è£œåŠ©é–¢æ•°ã®å®šç¾©
const calculateBounds = (shapes: Shape[]): { left: number; right: number; top: number; bottom: number } => {
  const xs = shapes.flatMap(s => [s.x, s.x + (s.width ?? 0)]);
  const ys = shapes.flatMap(s => [s.y, s.y + (s.height ?? 0)]);
  return {
    left: Math.min(...xs),
    right: Math.max(...xs),
    top: Math.min(...ys),
    bottom: Math.max(...ys)
  };
};

// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè£…ï¼ˆDIãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨ï¼‰
const createAlignmentActions = (getStore: () => WhiteboardStore) => ({
  alignShapesLeft: ({ context }) => {
    const store = getStore();
    const selectedShapes = Array.from(context.selectedIds)
      .map(id => store.shapes.get(id))
      .filter(Boolean);
    
    if (selectedShapes.length < 2) return;
    
    // æœ€ã‚‚å·¦ã®Shapeã‚’åŸºæº–ã«æ•´åˆ—
    // æœ€ã‚‚å·¦ã®Shapeã‚’åŸºæº–ã«æ•´åˆ—
    const leftMost = Math.min(...selectedShapes.map(s => s.x));
    
    selectedShapes.forEach(shape => {
      store.updateShape(shape.id, { x: leftMost });
    });
  },
  
  alignShapesCenterHorizontal: ({ context }) => {
    const store = getStore();
    const selectedShapes = Array.from(context.selectedIds)
      .map(id => store.shapes.get(id))
      .filter(Boolean);
    
    if (selectedShapes.length < 2) return;
    
    // é¸æŠç¯„å›²ã®ä¸­å¿ƒã‚’è¨ˆç®—
    const bounds = calculateBounds(selectedShapes);
    const centerX = (bounds.left + bounds.right) / 2;
    
    selectedShapes.forEach(shape => {
      // widthãŒå­˜åœ¨ã—ãªã„å ´åˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­å®š
      const width = shape.width ?? 0;
      const shapeCenter = shape.x + width / 2;
      const offset = centerX - shapeCenter;
      store.updateShape(shape.id, { x: shape.x + offset });
    });
  },
  // ä»–ã®æ•´åˆ—ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚‚åŒæ§˜ã«å®Ÿè£…...
});

// ä½¿ç”¨ä¾‹:ã‚¹ãƒˆã‚¢ã‚’æ³¨å…¥ã—ã¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ
const actions = createAlignmentActions(() => whiteboardStore.getState());
```

#### 0.2 ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã®è¿½åŠ 

```typescript
// packages/react-canvas/src/hooks/use-keyboard-shortcuts.ts

const alignmentShortcuts = {
  'ctrl+shift+ArrowLeft': () => sendEvent({ type: 'ALIGN_LEFT' }),
  'ctrl+shift+ArrowRight': () => sendEvent({ type: 'ALIGN_RIGHT' }),
  'ctrl+shift+ArrowUp': () => sendEvent({ type: 'ALIGN_TOP' }),
  'ctrl+shift+ArrowDown': () => sendEvent({ type: 'ALIGN_BOTTOM' }),
  'ctrl+shift+c': () => sendEvent({ type: 'ALIGN_CENTER_H' }),
  'ctrl+shift+m': () => sendEvent({ type: 'ALIGN_CENTER_V' }),
};
```

#### 0.3 å‹•ä½œç¢ºèª
- è¤‡æ•°ã®Shapeã‚’é¸æŠ
- ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã§æ•´åˆ—ã‚’å®Ÿè¡Œ
- æ­£ã—ãæ•´åˆ—ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª

### Phase 1: SnapEngineå®Ÿè£…ï¼ˆ2æ—¥ï¼‰

#### 1.1 SnapEngineã®åŸºæœ¬å®Ÿè£…

```typescript
// packages/tools/src/utils/snap-engine.ts

export class SnapEngine {
  private gridSize = 10;
  private snapThreshold = 8;
  
  // Step 1: ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—ã®å®Ÿè£…
  snap(position: Point, options?: SnapOptions): Point {
    if (!options?.snapEnabled) return position;
    
    if (options.gridSnap) {
      return {
        x: Math.round(position.x / this.gridSize) * this.gridSize,
        y: Math.round(position.y / this.gridSize) * this.gridSize
      };
    }
    
    return position;
  }
  
  // Step 2: Shapeé–“ã‚¹ãƒŠãƒƒãƒ—ã®è¿½åŠ 
  snapToShapes(
    movingShape: Shape,
    targetShapes: Shape[],
    currentPosition: Point
  ): SnapResult {
    const snapPoints = this.findSnapPoints(movingShape, targetShapes);
    const snappedPosition = this.calculateSnappedPosition(
      currentPosition,
      snapPoints
    );
    
    return {
      position: snappedPosition,
      guides: this.generateGuides(snapPoints)
    };
  }
  
  // æ•´åˆ—è¨ˆç®—ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆPhase 0ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç§»æ¤ï¼‰
  calculateAlignment(
    shapes: Shape[],
    alignment: AlignmentType
  ): Map<string, Point> {
    const updates = new Map<string, Point>();
    
    switch (alignment) {
      case 'left':
        const leftMost = Math.min(...shapes.map(s => s.x));
        shapes.forEach(shape => {
          updates.set(shape.id, { x: leftMost, y: shape.y });
        });
        break;
      // ä»–ã®ã‚±ãƒ¼ã‚¹ã‚‚å®Ÿè£…...
    }
    
    return updates;
  }
}
```

#### 1.2 SelectToolã¨ã®çµ±åˆ

```typescript
// packages/tools/src/tools/select-tool.ts

// translatingçŠ¶æ…‹ã§SnapEngineã‚’ä½¿ç”¨
translating: {
  invoke: {
    id: 'snappingService',
    src: fromCallback(({ sendBack, receive }) => {
      const snapEngine = new SnapEngine();
      
      receive((event: any) => {
        if (event.type === "SNAP_REQUEST") {
          const result = snapEngine.snap(event.position, {
            snapEnabled: true,
            gridSnap: event.gridSnap
          });
          sendBack({ type: "SNAP_RESPONSE", position: result });
        }
      });
    })
  },
  on: {
    POINTER_MOVE: {
      actions: [
        // SnapEngineã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
        send(
          ({ event }) => ({
            type: 'SNAP_REQUEST',
            position: event.position,
            gridSnap: true
          }),
          { to: 'snappingService' }
        )
      ]
    },
    SNAP_RESPONSE: {
      actions: 'updateSnappedPosition'
    }
  }
}
```

### Phase 2: UIçµ±åˆï¼ˆ2æ—¥ï¼‰

#### 2.1 æ•´åˆ—ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```typescript
// packages/ui-components/src/alignment-toolbar.tsx

export const AlignmentToolbar: React.FC<AlignmentToolbarProps> = ({
  onAlign,
  selectedCount
}) => {
  if (selectedCount < 2) return null;
  
  return (
    <div className="alignment-toolbar">
      <button onClick={() => onAlign('left')} title="Align Left">
        <AlignLeftIcon />
      </button>
      <button onClick={() => onAlign('center-h')} title="Align Center">
        <AlignCenterHIcon />
      </button>
      <button onClick={() => onAlign('right')} title="Align Right">
        <AlignRightIcon />
      </button>
      <Separator />
      <button onClick={() => onAlign('top')} title="Align Top">
        <AlignTopIcon />
      </button>
      <button onClick={() => onAlign('center-v')} title="Align Middle">
        <AlignCenterVIcon />
      </button>
      <button onClick={() => onAlign('bottom')} title="Align Bottom">
        <AlignBottomIcon />
      </button>
    </div>
  );
};
```

#### 2.2 SelectionLayerã¨ã®çµ±åˆ

```typescript
// packages/react-canvas/src/layers/selection-layer.tsx

// ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ãƒãƒƒãƒ”ãƒ³ã‚°
const ALIGNMENT_EVENT_MAP: Record<AlignmentType, string> = {
  'left': 'ALIGN_LEFT',
  'center-h': 'ALIGN_CENTER_H',
  'right': 'ALIGN_RIGHT',
  'top': 'ALIGN_TOP',
  'center-v': 'ALIGN_CENTER_V',
  'bottom': 'ALIGN_BOTTOM',
};

export const SelectionLayer: React.FC = () => {
  const selectedIds = useWhiteboardStore(state => state.selectedIds);
  const sendEvent = useToolManager();
  
  const handleAlign = (alignment: AlignmentType) => {
    const eventType = ALIGNMENT_EVENT_MAP[alignment];
    if (!eventType) {
      console.warn(`Unknown alignment type: ${alignment}`);
      return;
    }
    sendEvent({ type: eventType });
  };
  
  return (
    <>
      {selectedIds.size > 1 && (
        <AlignmentToolbar
          selectedCount={selectedIds.size}
          onAlign={handleAlign}
        />
      )}
      {/* æ—¢å­˜ã®é¸æŠãƒãƒ³ãƒ‰ãƒ« */}
      <SelectionHandles />
    </>
  );
};
```

### Phase 3: ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³è¡¨ç¤ºï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒ»3æ—¥ï¼‰

å¾Œç¶šãƒ•ã‚§ãƒ¼ã‚ºã¨ã—ã¦ã€ä»¥ä¸‹ã®é«˜åº¦ãªæ©Ÿèƒ½ã‚’è¿½åŠ ï¼š
- ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³è¡¨ç¤º
- ã‚¹ãƒŠãƒƒãƒ—ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
- ç­‰é–“éš”åˆ†å¸ƒæ©Ÿèƒ½
- ã‚°ãƒ«ãƒ¼ãƒ—æ•´åˆ—

## ğŸ” å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### Phase 0ï¼ˆMVPï¼‰
- [ ] SelectToolã«æ•´åˆ—ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
- [ ] æ•´åˆ—ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å®Ÿè£…ï¼ˆç›´æ¥çš„ãªä½ç½®æ›´æ–°ï¼‰
- [ ] ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã®è¨­å®š
- [ ] è¤‡æ•°Shapeé¸æŠæ™‚ã®å‹•ä½œç¢ºèª
- [ ] å„æ•´åˆ—æ–¹å‘ã®å‹•ä½œãƒ†ã‚¹ãƒˆ

### Phase 1ï¼ˆåŸºæœ¬æ©Ÿèƒ½ï¼‰
- [ ] SnapEngineã®åŸºæœ¬å®Ÿè£…
- [ ] ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—æ©Ÿèƒ½
- [ ] Shapeé–“ã‚¹ãƒŠãƒƒãƒ—æ©Ÿèƒ½
- [ ] SelectToolã¨ã®çµ±åˆ
- [ ] translatingçŠ¶æ…‹ã§ã®ã‚¹ãƒŠãƒƒãƒ—å‹•ä½œç¢ºèª

### Phase 2ï¼ˆUIçµ±åˆï¼‰
- [ ] AlignmentToolbarã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆä½œæˆ
- [ ] SelectionLayerã¨ã®çµ±åˆ
- [ ] ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®è¡¨ç¤º/éè¡¨ç¤ºåˆ¶å¾¡
- [ ] UIã‹ã‚‰ã®æ•´åˆ—å®Ÿè¡Œãƒ†ã‚¹ãƒˆ

## ğŸ“Š æˆåŠŸæŒ‡æ¨™

### Phase 0
- ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã§æ•´åˆ—ãŒå®Ÿè¡Œã§ãã‚‹
- é¸æŠã—ãŸå…¨ã¦ã®ShapeãŒæ­£ã—ãæ•´åˆ—ã•ã‚Œã‚‹
- æ—¢å­˜æ©Ÿèƒ½ã¸ã®å½±éŸ¿ãŒãªã„

### Phase 1
- ãƒ‰ãƒ©ãƒƒã‚°æ™‚ã«ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—ãŒå‹•ä½œã™ã‚‹
- Shapeé–“ã®ã‚¹ãƒŠãƒƒãƒ—ãŒæ©Ÿèƒ½ã™ã‚‹

### Phase 2
- UIã‹ã‚‰æ•´åˆ—æ“ä½œãŒã§ãã‚‹
- ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ãŒå‘ä¸Šã™ã‚‹

## âš ï¸ ãƒªã‚¹ã‚¯ã¨å¯¾ç­–

### æŠ€è¡“çš„ãƒªã‚¹ã‚¯
1. **XState v5ã®è¤‡é›‘æ€§**
   - å¯¾ç­–: ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰å§‹ã‚ã‚‹
   
2. **Zustandã®çŠ¶æ…‹æ›´æ–°**
   - å¯¾ç­–: æ—¢å­˜ã®updateShapeãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨
   
3. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œ**
   - å¯¾ç­–: æœ€åˆã¯æœ€é©åŒ–ã›ãšã€å‹•ä½œã‚’å„ªå…ˆ

### å®Ÿè£…ä¸Šã®æ³¨æ„ç‚¹
- **æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã‚’æœ€å¤§é™æ´»ç”¨** - æ–°è¦å®Ÿè£…ã‚’æœ€å°é™ã«
- **æ®µéšçš„ã«ãƒ†ã‚¹ãƒˆ** - å„ãƒ•ã‚§ãƒ¼ã‚ºã§å‹•ä½œç¢ºèª
- **ã‚³ãƒŸãƒƒãƒˆã‚’ç´°ã‹ã** - å•é¡Œç™ºç”Ÿæ™‚ã«ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å¯èƒ½ã«

## ğŸ“… æ¨å®šã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

- Phase 0: 1æ—¥ï¼ˆå³åº§ã«æˆæœã‚’ç¢ºèªï¼‰
- Phase 1: 2æ—¥ï¼ˆåŸºæœ¬æ©Ÿèƒ½ã®å®Œæˆï¼‰
- Phase 2: 2æ—¥ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘æ©Ÿèƒ½ï¼‰
- **åˆè¨ˆ: 5å–¶æ¥­æ—¥**ï¼ˆå¾“æ¥ã®8-10æ—¥ã‹ã‚‰çŸ­ç¸®ï¼‰

## ğŸš€ æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³

1. **Phase 0ã®å®Ÿè£…ã‚’å³åº§ã«é–‹å§‹**
2. å‹•ä½œç¢ºèªå¾Œã€Phase 1ã¸é€²ã‚€
3. å„ãƒ•ã‚§ãƒ¼ã‚ºã§æˆæœã‚’ç¢ºèªã—ãªãŒã‚‰é€²ã‚ã‚‹

ã“ã®æ”¹è¨‚ç‰ˆã§ã¯ã€**ç¢ºå®Ÿã«å‹•ä½œã™ã‚‹æœ€å°å®Ÿè£…ã‹ã‚‰å§‹ã‚ã€æ®µéšçš„ã«æ©Ÿèƒ½ã‚’è¿½åŠ **ã™ã‚‹ã“ã¨ã§ã€éå»ã®å¤±æ•—ã‚’é¿ã‘ãªãŒã‚‰ç€å®Ÿã«æ•´åˆ—æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã¾ã™ã€‚