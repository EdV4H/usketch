# ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆçµ±åˆã‚¬ã‚¤ãƒ‰

## ğŸ¯ æ¦‚è¦

ã“ã®ã‚¬ã‚¤ãƒ‰ã¯ã€DOMãƒ›ãƒ¯ã‚¤ãƒˆãƒœãƒ¼ãƒ‰ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æ–°ã—ã„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼ˆSelectionLayerã€ToolManagerã€Toolï¼‰ã‚’æ—¢å­˜ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«çµ±åˆã™ã‚‹ãŸã‚ã®åŒ…æ‹¬çš„ãªæŒ‡é‡ã‚’æä¾›ã—ã¾ã™ã€‚

## ğŸ—ï¸ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### å…¨ä½“æ§‹æˆå›³

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    WhiteboardCanvas                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                  CanvasContainer                  â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚  ShapeLayer   â”‚  â”‚  SelectionLayer    â”‚    â”‚   â”‚
â”‚  â”‚  â”‚               â”‚  â”‚                     â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â”‚ Shape 1 â”‚ â”‚  â”‚  â”‚ Selection Boxâ”‚  â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â”‚ Shape 2 â”‚ â”‚  â”‚  â”‚Resize Handlesâ”‚  â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                  ToolManager                     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚SelectToolâ”‚ â”‚RectTool  â”‚ â”‚ EllipseTool  â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚               WhiteboardStore                    â”‚   â”‚
â”‚  â”‚         (shapes, selection, tools)               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“¦ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆè©³ç´°

### 1. SelectionLayer

**è²¬å‹™:**
- é¸æŠã•ã‚ŒãŸShapeã®è¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
- ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã®è¡¨ç¤ºã¨ç®¡ç†
- é¸æŠãƒœãƒƒã‚¯ã‚¹ã®æç”»
- è¤‡æ•°é¸æŠã®è¦–è¦šåŒ–

```typescript
// src/components/SelectionLayer.ts
export interface SelectionLayerProps {
  container: HTMLElement;
  store: WhiteboardStore;
}

export class SelectionLayer {
  private element: HTMLElement;
  private selectionBox: HTMLElement | null = null;
  private resizeHandles: Map<string, HTMLElement> = new Map();
  
  constructor(private props: SelectionLayerProps) {
    this.element = this.createElement();
    this.setupStoreSubscription();
    this.attachToContainer();
  }
  
  private createElement(): HTMLElement {
    const element = document.createElement('div');
    element.className = 'selection-layer';
    element.setAttribute('data-layer', 'selection');
    element.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
    `;
    return element;
  }
  
  private setupStoreSubscription(): void {
    // ã‚¹ãƒˆã‚¢ã®é¸æŠçŠ¶æ…‹ã‚’ç›£è¦–
    this.props.store.subscribe(
      state => state.selectedShapeIds,
      selectedIds => this.updateSelection(selectedIds)
    );
  }
  
  private updateSelection(selectedIds: string[]): void {
    this.clearSelection();
    
    if (selectedIds.length === 0) return;
    
    if (selectedIds.length === 1) {
      this.showSingleSelection(selectedIds[0]);
    } else {
      this.showMultipleSelection(selectedIds);
    }
  }
  
  private showSingleSelection(shapeId: string): void {
    const shape = this.props.store.getShape(shapeId);
    if (!shape) return;
    
    // é¸æŠãƒœãƒƒã‚¯ã‚¹ã‚’ä½œæˆ
    this.selectionBox = this.createSelectionBox(shape);
    this.element.appendChild(this.selectionBox);
    
    // ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã‚’ä½œæˆ
    this.createResizeHandles(shape);
  }
  
  private createSelectionBox(shape: Shape): HTMLElement {
    const box = document.createElement('div');
    box.className = 'selection-box';
    box.setAttribute('data-shape-id', shape.id);
    box.setAttribute('data-selection-type', 'single');
    
    const bounds = this.calculateBounds(shape);
    box.style.cssText = `
      position: absolute;
      left: ${bounds.x}px;
      top: ${bounds.y}px;
      width: ${bounds.width}px;
      height: ${bounds.height}px;
      border: 2px solid #0066ff;
      pointer-events: none;
    `;
    
    return box;
  }
  
  private createResizeHandles(shape: Shape): void {
    const handles = [
      { position: 'nw', cursor: 'nw-resize' },
      { position: 'n', cursor: 'n-resize' },
      { position: 'ne', cursor: 'ne-resize' },
      { position: 'e', cursor: 'e-resize' },
      { position: 'se', cursor: 'se-resize' },
      { position: 's', cursor: 's-resize' },
      { position: 'sw', cursor: 'sw-resize' },
      { position: 'w', cursor: 'w-resize' },
    ];
    
    handles.forEach(({ position, cursor }) => {
      const handle = this.createResizeHandle(shape, position, cursor);
      this.resizeHandles.set(position, handle);
      this.selectionBox!.appendChild(handle);
    });
  }
  
  private createResizeHandle(
    shape: Shape,
    position: string,
    cursor: string
  ): HTMLElement {
    const handle = document.createElement('div');
    handle.className = 'resize-handle';
    handle.setAttribute('data-resize-handle', position);
    handle.setAttribute('data-shape-id', shape.id);
    handle.style.cssText = `
      position: absolute;
      width: 8px;
      height: 8px;
      background: white;
      border: 2px solid #0066ff;
      border-radius: 2px;
      cursor: ${cursor};
      pointer-events: auto;
      ${this.getHandlePosition(position)}
    `;
    
    // ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆã®è¨­å®š
    handle.addEventListener('mousedown', this.handleResizeStart.bind(this));
    
    return handle;
  }
  
  private getHandlePosition(position: string): string {
    const positions: Record<string, string> = {
      'nw': 'top: -5px; left: -5px;',
      'n': 'top: -5px; left: 50%; transform: translateX(-50%);',
      'ne': 'top: -5px; right: -5px;',
      'e': 'top: 50%; right: -5px; transform: translateY(-50%);',
      'se': 'bottom: -5px; right: -5px;',
      's': 'bottom: -5px; left: 50%; transform: translateX(-50%);',
      'sw': 'bottom: -5px; left: -5px;',
      'w': 'top: 50%; left: -5px; transform: translateY(-50%);',
    };
    return positions[position] || '';
  }
  
  private handleResizeStart(event: MouseEvent): void {
    event.stopPropagation();
    const handle = event.target as HTMLElement;
    const position = handle.getAttribute('data-resize-handle')!;
    const shapeId = handle.getAttribute('data-shape-id')!;
    
    // ToolManagerã«ãƒªã‚µã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ã‚’é€šçŸ¥
    this.props.store.setResizing({
      shapeId,
      handle: position,
      startPoint: { x: event.clientX, y: event.clientY },
    });
  }
  
  private clearSelection(): void {
    if (this.selectionBox) {
      this.selectionBox.remove();
      this.selectionBox = null;
    }
    this.resizeHandles.clear();
  }
  
  destroy(): void {
    this.clearSelection();
    this.element.remove();
  }
}
```

### 2. ToolManager

**è²¬å‹™:**
- ç¾åœ¨ã®ãƒ„ãƒ¼ãƒ«ã®ç®¡ç†
- ãƒ„ãƒ¼ãƒ«é–“ã®åˆ‡ã‚Šæ›¿ãˆ
- ã‚¤ãƒ™ãƒ³ãƒˆã®é©åˆ‡ãªãƒ„ãƒ¼ãƒ«ã¸ã®å§”è­²
- ãƒ„ãƒ¼ãƒ«ã®ç™»éŒ²ã¨å‰Šé™¤

```typescript
// src/tools/ToolManager.ts
export interface Tool {
  id: string;
  name: string;
  icon?: string;
  cursor: string;
  
  // ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«
  onActivate(context: ToolContext): void;
  onDeactivate(): void;
  
  // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
  onPointerDown?(event: PointerEvent, context: ToolContext): void;
  onPointerMove?(event: PointerEvent, context: ToolContext): void;
  onPointerUp?(event: PointerEvent, context: ToolContext): void;
  onKeyDown?(event: KeyboardEvent, context: ToolContext): void;
  onKeyUp?(event: KeyboardEvent, context: ToolContext): void;
  onDoubleClick?(event: MouseEvent, context: ToolContext): void;
  
  // çŠ¶æ…‹
  canUndo?(): boolean;
  canRedo?(): boolean;
}

export interface ToolContext {
  store: WhiteboardStore;
  canvas: HTMLElement;
  screenToWorld: (point: Point) => Point;
  worldToScreen: (point: Point) => Point;
  startTransaction: () => void;
  commitTransaction: () => void;
  cancelTransaction: () => void;
}

export class ToolManager {
  private tools: Map<string, Tool> = new Map();
  private activeTool: Tool | null = null;
  private context: ToolContext;
  private listeners: Map<string, EventListener> = new Map();
  
  constructor(
    private container: HTMLElement,
    private store: WhiteboardStore
  ) {
    this.context = this.createContext();
    this.setupEventListeners();
    this.registerDefaultTools();
  }
  
  private createContext(): ToolContext {
    return {
      store: this.store,
      canvas: this.container,
      screenToWorld: (point: Point) => this.screenToWorld(point),
      worldToScreen: (point: Point) => this.worldToScreen(point),
      startTransaction: () => this.store.startTransaction(),
      commitTransaction: () => this.store.commitTransaction(),
      cancelTransaction: () => this.store.cancelTransaction(),
    };
  }
  
  private setupEventListeners(): void {
    // ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ
    this.addListener('pointerdown', (e: PointerEvent) => {
      this.activeTool?.onPointerDown?.(e, this.context);
    });
    
    this.addListener('pointermove', (e: PointerEvent) => {
      this.activeTool?.onPointerMove?.(e, this.context);
    });
    
    this.addListener('pointerup', (e: PointerEvent) => {
      this.activeTool?.onPointerUp?.(e, this.context);
    });
    
    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆ
    document.addEventListener('keydown', (e: KeyboardEvent) => {
      this.activeTool?.onKeyDown?.(e, this.context);
    });
    
    document.addEventListener('keyup', (e: KeyboardEvent) => {
      this.activeTool?.onKeyUp?.(e, this.context);
    });
    
    // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯
    this.addListener('dblclick', (e: MouseEvent) => {
      this.activeTool?.onDoubleClick?.(e, this.context);
    });
  }
  
  private addListener(event: string, handler: EventListener): void {
    this.container.addEventListener(event, handler);
    this.listeners.set(event, handler);
  }
  
  registerTool(tool: Tool): void {
    this.tools.set(tool.id, tool);
    
    // æœ€åˆã®ãƒ„ãƒ¼ãƒ«ã‚’è‡ªå‹•çš„ã«ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«
    if (!this.activeTool && this.tools.size === 1) {
      this.setActiveTool(tool.id);
    }
  }
  
  unregisterTool(toolId: string): void {
    const tool = this.tools.get(toolId);
    if (!tool) return;
    
    if (this.activeTool === tool) {
      this.activeTool.onDeactivate();
      this.activeTool = null;
    }
    
    this.tools.delete(toolId);
  }
  
  setActiveTool(toolId: string): void {
    const tool = this.tools.get(toolId);
    if (!tool || tool === this.activeTool) return;
    
    // ç¾åœ¨ã®ãƒ„ãƒ¼ãƒ«ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    if (this.activeTool) {
      this.activeTool.onDeactivate();
    }
    
    // æ–°ã—ã„ãƒ„ãƒ¼ãƒ«ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    this.activeTool = tool;
    tool.onActivate(this.context);
    
    // ã‚«ãƒ¼ã‚½ãƒ«ã‚’æ›´æ–°
    this.container.style.cursor = tool.cursor;
    
    // ã‚¹ãƒˆã‚¢ã«é€šçŸ¥
    this.store.setActiveTool(toolId);
  }
  
  getActiveTool(): Tool | null {
    return this.activeTool;
  }
  
  getAllTools(): Tool[] {
    return Array.from(this.tools.values());
  }
  
  // åº§æ¨™å¤‰æ›ãƒ˜ãƒ«ãƒ‘ãƒ¼
  private screenToWorld(point: Point): Point {
    const rect = this.container.getBoundingClientRect();
    const camera = this.store.getCamera();
    
    return {
      x: (point.x - rect.left - rect.width / 2) / camera.zoom + camera.x,
      y: (point.y - rect.top - rect.height / 2) / camera.zoom + camera.y,
    };
  }
  
  private worldToScreen(point: Point): Point {
    const rect = this.container.getBoundingClientRect();
    const camera = this.store.getCamera();
    
    return {
      x: (point.x - camera.x) * camera.zoom + rect.width / 2 + rect.left,
      y: (point.y - camera.y) * camera.zoom + rect.height / 2 + rect.top,
    };
  }
  
  private registerDefaultTools(): void {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ„ãƒ¼ãƒ«ã®ç™»éŒ²
    this.registerTool(new SelectTool());
    this.registerTool(new RectangleTool());
    this.registerTool(new EllipseTool());
  }
  
  destroy(): void {
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®å‰Šé™¤
    this.listeners.forEach((handler, event) => {
      this.container.removeEventListener(event, handler);
    });
    this.listeners.clear();
    
    // ãƒ„ãƒ¼ãƒ«ã®éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
    if (this.activeTool) {
      this.activeTool.onDeactivate();
    }
    
    this.tools.clear();
  }
}
```

### 3. Toolå®Ÿè£…ä¾‹

#### SelectTool

```typescript
// src/tools/SelectTool.ts
export class SelectTool implements Tool {
  id = 'select';
  name = 'Select';
  icon = 'cursor';
  cursor = 'default';
  
  private isDragging = false;
  private dragStart: Point | null = null;
  private selectedShapes: string[] = [];
  
  onActivate(context: ToolContext): void {
    console.log('Select tool activated');
  }
  
  onDeactivate(): void {
    this.isDragging = false;
    this.dragStart = null;
  }
  
  onPointerDown(event: PointerEvent, context: ToolContext): void {
    const worldPoint = context.screenToWorld({
      x: event.clientX,
      y: event.clientY,
    });
    
    // Shapeã®ãƒ’ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
    const hitShape = this.findShapeAtPoint(worldPoint, context);
    
    if (hitShape) {
      // Shapeã‚’ã‚¯ãƒªãƒƒã‚¯
      if (event.shiftKey || event.ctrlKey || event.metaKey) {
        // è¤‡æ•°é¸æŠ
        this.toggleShapeSelection(hitShape.id, context);
      } else {
        // å˜ä¸€é¸æŠ
        context.store.selectShape(hitShape.id);
        this.selectedShapes = [hitShape.id];
      }
      
      // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
      this.isDragging = true;
      this.dragStart = worldPoint;
    } else {
      // ç©ºç™½é ˜åŸŸã‚’ã‚¯ãƒªãƒƒã‚¯
      if (!event.shiftKey && !event.ctrlKey && !event.metaKey) {
        context.store.clearSelection();
        this.selectedShapes = [];
      }
    }
  }
  
  onPointerMove(event: PointerEvent, context: ToolContext): void {
    if (!this.isDragging || !this.dragStart) return;
    
    const worldPoint = context.screenToWorld({
      x: event.clientX,
      y: event.clientY,
    });
    
    const deltaX = worldPoint.x - this.dragStart.x;
    const deltaY = worldPoint.y - this.dragStart.y;
    
    // é¸æŠã•ã‚ŒãŸShapeã‚’ç§»å‹•
    context.startTransaction();
    
    this.selectedShapes.forEach(shapeId => {
      const shape = context.store.getShape(shapeId);
      if (shape) {
        context.store.updateShape(shapeId, {
          x: shape.x + deltaX,
          y: shape.y + deltaY,
        });
      }
    });
    
    context.commitTransaction();
    
    this.dragStart = worldPoint;
  }
  
  onPointerUp(event: PointerEvent, context: ToolContext): void {
    this.isDragging = false;
    this.dragStart = null;
  }
  
  onKeyDown(event: KeyboardEvent, context: ToolContext): void {
    // Delete/Backspace: é¸æŠã•ã‚ŒãŸShapeã‚’å‰Šé™¤
    if (event.key === 'Delete' || event.key === 'Backspace') {
      const selectedIds = context.store.getSelectedShapeIds();
      if (selectedIds.length > 0) {
        context.startTransaction();
        selectedIds.forEach(id => context.store.removeShape(id));
        context.commitTransaction();
      }
    }
    
    // Ctrl/Cmd + A: å…¨é¸æŠ
    if ((event.ctrlKey || event.metaKey) && event.key === 'a') {
      event.preventDefault();
      const allShapeIds = context.store.getAllShapes().map(s => s.id);
      context.store.selectMultipleShapes(allShapeIds);
    }
    
    // Escape: é¸æŠè§£é™¤
    if (event.key === 'Escape') {
      context.store.clearSelection();
    }
  }
  
  private findShapeAtPoint(point: Point, context: ToolContext): Shape | null {
    const shapes = context.store.getAllShapes();
    
    // å¾Œã‚ã‹ã‚‰å‰ã¸ï¼ˆä¸Šã‹ã‚‰ä¸‹ã¸ï¼‰æ¤œç´¢
    for (let i = shapes.length - 1; i >= 0; i--) {
      const shape = shapes[i];
      if (this.isPointInShape(point, shape)) {
        return shape;
      }
    }
    
    return null;
  }
  
  private isPointInShape(point: Point, shape: Shape): boolean {
    // ç°¡å˜ãªçŸ©å½¢åˆ¤å®šï¼ˆå®Ÿéš›ã¯å„Shapeã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸåˆ¤å®šãŒå¿…è¦ï¼‰
    return (
      point.x >= shape.x &&
      point.x <= shape.x + shape.width &&
      point.y >= shape.y &&
      point.y <= shape.y + shape.height
    );
  }
  
  private toggleShapeSelection(shapeId: string, context: ToolContext): void {
    const selectedIds = context.store.getSelectedShapeIds();
    
    if (selectedIds.includes(shapeId)) {
      // é¸æŠè§£é™¤
      const newSelection = selectedIds.filter(id => id !== shapeId);
      context.store.selectMultipleShapes(newSelection);
    } else {
      // é¸æŠè¿½åŠ 
      context.store.selectMultipleShapes([...selectedIds, shapeId]);
    }
    
    this.selectedShapes = context.store.getSelectedShapeIds();
  }
}
```

#### RectangleTool

```typescript
// src/tools/RectangleTool.ts
export class RectangleTool implements Tool {
  id = 'rectangle';
  name = 'Rectangle';
  icon = 'square';
  cursor = 'crosshair';
  
  private isDrawing = false;
  private startPoint: Point | null = null;
  private previewElement: HTMLElement | null = null;
  private currentShapeId: string | null = null;
  
  onActivate(context: ToolContext): void {
    console.log('Rectangle tool activated');
  }
  
  onDeactivate(): void {
    this.cancelDrawing();
  }
  
  onPointerDown(event: PointerEvent, context: ToolContext): void {
    if (event.button !== 0) return; // å·¦ã‚¯ãƒªãƒƒã‚¯ã®ã¿
    
    this.startPoint = context.screenToWorld({
      x: event.clientX,
      y: event.clientY,
    });
    
    this.isDrawing = true;
    
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¦ç´ ã‚’ä½œæˆ
    this.createPreview(context);
  }
  
  onPointerMove(event: PointerEvent, context: ToolContext): void {
    if (!this.isDrawing || !this.startPoint || !this.previewElement) return;
    
    const currentPoint = context.screenToWorld({
      x: event.clientX,
      y: event.clientY,
    });
    
    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ›´æ–°
    this.updatePreview(this.startPoint, currentPoint, context);
  }
  
  onPointerUp(event: PointerEvent, context: ToolContext): void {
    if (!this.isDrawing || !this.startPoint) return;
    
    const endPoint = context.screenToWorld({
      x: event.clientX,
      y: event.clientY,
    });
    
    // æœ€å°ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
    const width = Math.abs(endPoint.x - this.startPoint.x);
    const height = Math.abs(endPoint.y - this.startPoint.y);
    
    if (width >= 5 && height >= 5) {
      // Shapeã‚’ä½œæˆ
      context.startTransaction();
      
      const shape = context.store.addShape({
        type: 'rectangle',
        x: Math.min(this.startPoint.x, endPoint.x),
        y: Math.min(this.startPoint.y, endPoint.y),
        width,
        height,
        strokeColor: '#000000',
        fillColor: '#ffffff',
        strokeWidth: 2,
        rotation: 0,
        opacity: 1,
      });
      
      // ä½œæˆã—ãŸShapeã‚’é¸æŠ
      context.store.clearSelection();
      context.store.selectShape(shape.id);
      
      context.commitTransaction();
    }
    
    this.cancelDrawing();
  }
  
  onKeyDown(event: KeyboardEvent, context: ToolContext): void {
    // Escape: æç”»ã‚­ãƒ£ãƒ³ã‚»ãƒ«
    if (event.key === 'Escape') {
      this.cancelDrawing();
    }
  }
  
  private createPreview(context: ToolContext): void {
    this.previewElement = document.createElement('div');
    this.previewElement.className = 'shape-preview rectangle-preview';
    this.previewElement.style.cssText = `
      position: absolute;
      border: 2px dashed #0066ff;
      background: rgba(0, 102, 255, 0.1);
      pointer-events: none;
      z-index: 999;
    `;
    
    const shapeLayer = context.canvas.querySelector('.shape-layer');
    if (shapeLayer) {
      shapeLayer.appendChild(this.previewElement);
    }
  }
  
  private updatePreview(
    start: Point,
    current: Point,
    context: ToolContext
  ): void {
    if (!this.previewElement) return;
    
    const screenStart = context.worldToScreen(start);
    const screenCurrent = context.worldToScreen(current);
    
    const x = Math.min(screenStart.x, screenCurrent.x);
    const y = Math.min(screenStart.y, screenCurrent.y);
    const width = Math.abs(screenCurrent.x - screenStart.x);
    const height = Math.abs(screenCurrent.y - screenStart.y);
    
    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®å¢ƒç•Œã‚’å–å¾—
    const rect = context.canvas.getBoundingClientRect();
    
    this.previewElement.style.left = `${x - rect.left}px`;
    this.previewElement.style.top = `${y - rect.top}px`;
    this.previewElement.style.width = `${width}px`;
    this.previewElement.style.height = `${height}px`;
  }
  
  private cancelDrawing(): void {
    this.isDrawing = false;
    this.startPoint = null;
    
    if (this.previewElement) {
      this.previewElement.remove();
      this.previewElement = null;
    }
  }
}
```

## ğŸ”Œ çµ±åˆæ‰‹é †

### 1. ä¾å­˜é–¢ä¿‚ã®æ³¨å…¥

```typescript
// src/WhiteboardCanvas.ts
export class WhiteboardCanvas {
  private container: HTMLElement;
  private store: WhiteboardStore;
  private shapeLayer: HTMLElement;
  private selectionLayer: SelectionLayer;
  private toolManager: ToolManager;
  
  constructor(container: HTMLElement) {
    this.container = container;
    this.store = useWhiteboardStore;
    
    this.initializeCanvas();
    this.initializeComponents();
    this.setupEventHandlers();
  }
  
  private initializeCanvas(): void {
    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚³ãƒ³ãƒ†ãƒŠã®è¨­å®š
    this.container.className = 'whiteboard-canvas';
    this.container.setAttribute('data-canvas-ready', 'true');
    this.container.style.cssText = `
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #f5f5f5;
    `;
    
    // Shapeãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½œæˆ
    this.shapeLayer = document.createElement('div');
    this.shapeLayer.className = 'shape-layer';
    this.shapeLayer.setAttribute('data-layer', 'shapes');
    this.shapeLayer.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    `;
    this.container.appendChild(this.shapeLayer);
  }
  
  private initializeComponents(): void {
    // SelectionLayerã®åˆæœŸåŒ–
    this.selectionLayer = new SelectionLayer({
      container: this.container,
      store: this.store,
    });
    
    // ToolManagerã®åˆæœŸåŒ–
    this.toolManager = new ToolManager(this.container, this.store);
    
    // ã‚«ã‚¹ã‚¿ãƒ ãƒ„ãƒ¼ãƒ«ã®ç™»éŒ²
    this.registerCustomTools();
  }
  
  private registerCustomTools(): void {
    // å¿…è¦ã«å¿œã˜ã¦ã‚«ã‚¹ã‚¿ãƒ ãƒ„ãƒ¼ãƒ«ã‚’ç™»éŒ²
    // this.toolManager.registerTool(new CustomTool());
  }
  
  private setupEventHandlers(): void {
    // ã‚¹ãƒˆã‚¢ã®å¤‰æ›´ã‚’ç›£è¦–
    this.store.subscribe(
      state => state.shapes,
      shapes => this.renderShapes(shapes)
    );
    
    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
    document.addEventListener('keydown', this.handleKeyDown.bind(this));
  }
  
  private handleKeyDown(event: KeyboardEvent): void {
    // ãƒ„ãƒ¼ãƒ«åˆ‡ã‚Šæ›¿ãˆã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
    const shortcuts: Record<string, string> = {
      'v': 'select',      // V: Select tool
      'r': 'rectangle',   // R: Rectangle tool
      'e': 'ellipse',     // E: Ellipse tool
    };
    
    const toolId = shortcuts[event.key.toLowerCase()];
    if (toolId && !event.ctrlKey && !event.metaKey) {
      this.toolManager.setActiveTool(toolId);
    }
  }
  
  private renderShapes(shapes: Shape[]): void {
    // æ—¢å­˜ã®Shapeã‚’ã‚¯ãƒªã‚¢
    this.shapeLayer.innerHTML = '';
    
    // Shapeã‚’å†æç”»
    shapes.forEach(shape => {
      const element = this.createShapeElement(shape);
      this.shapeLayer.appendChild(element);
    });
  }
  
  private createShapeElement(shape: Shape): HTMLElement {
    const element = document.createElement('div');
    element.className = `shape shape-${shape.type}`;
    element.setAttribute('data-shape-id', shape.id);
    element.setAttribute('data-shape-type', shape.type);
    element.setAttribute('data-shape', 'true'); // E2Eãƒ†ã‚¹ãƒˆäº’æ›æ€§ã®ãŸã‚
    
    // ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š
    element.style.cssText = `
      position: absolute;
      transform: translate(${shape.x}px, ${shape.y}px);
      width: ${shape.width}px;
      height: ${shape.height}px;
      background: ${shape.fillColor};
      border: ${shape.strokeWidth}px solid ${shape.strokeColor};
      opacity: ${shape.opacity};
    `;
    
    // é¸æŠçŠ¶æ…‹ã®åæ˜ 
    if (this.store.getSelectedShapeIds().includes(shape.id)) {
      element.setAttribute('data-shape-selected', 'true');
      element.setAttribute('data-selected', 'true'); // E2Eãƒ†ã‚¹ãƒˆäº’æ›æ€§
      element.classList.add('selected');
    }
    
    return element;
  }
  
  // Public API
  setActiveTool(toolId: string): void {
    this.toolManager.setActiveTool(toolId);
  }
  
  getActiveTool(): Tool | null {
    return this.toolManager.getActiveTool();
  }
  
  addCustomTool(tool: Tool): void {
    this.toolManager.registerTool(tool);
  }
  
  destroy(): void {
    this.selectionLayer.destroy();
    this.toolManager.destroy();
    this.container.innerHTML = '';
  }
}
```

### 2. ã‚¹ãƒˆã‚¢ã®æ‹¡å¼µ

```typescript
// src/store.ts
interface ToolState {
  activeTool: string;
  toolOptions: Record<string, any>;
  isResizing: boolean;
  resizeInfo: ResizeInfo | null;
}

interface ResizeInfo {
  shapeId: string;
  handle: string;
  startPoint: Point;
}

interface TransactionState {
  isInTransaction: boolean;
  transactionShapes: Shape[];
}

export interface WhiteboardState {
  shapes: Shape[];
  selectedShapeIds: string[];
  camera: Camera;
  tool: ToolState;
  transaction: TransactionState;
}

export const useWhiteboardStore = create<WhiteboardState & Actions>((set, get) => ({
  // åˆæœŸçŠ¶æ…‹
  shapes: [],
  selectedShapeIds: [],
  camera: { x: 0, y: 0, zoom: 1 },
  tool: {
    activeTool: 'select',
    toolOptions: {},
    isResizing: false,
    resizeInfo: null,
  },
  transaction: {
    isInTransaction: false,
    transactionShapes: [],
  },
  
  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
  setActiveTool: (toolId: string) => {
    set(state => ({
      tool: {
        ...state.tool,
        activeTool: toolId,
      },
    }));
  },
  
  setResizing: (resizeInfo: ResizeInfo | null) => {
    set(state => ({
      tool: {
        ...state.tool,
        isResizing: resizeInfo !== null,
        resizeInfo,
      },
    }));
  },
  
  startTransaction: () => {
    const currentShapes = get().shapes;
    set(state => ({
      transaction: {
        isInTransaction: true,
        transactionShapes: [...currentShapes],
      },
    }));
  },
  
  commitTransaction: () => {
    set(state => ({
      transaction: {
        isInTransaction: false,
        transactionShapes: [],
      },
    }));
    
    // ã“ã“ã§Undo/Redoã‚¹ã‚¿ãƒƒã‚¯ã«è¿½åŠ 
  },
  
  cancelTransaction: () => {
    const { transactionShapes } = get().transaction;
    set(state => ({
      shapes: transactionShapes,
      transaction: {
        isInTransaction: false,
        transactionShapes: [],
      },
    }));
  },
  
  // æ—¢å­˜ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³...
}));
```

## ğŸ§ª ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ

```typescript
// tests/SelectionLayer.test.ts
describe('SelectionLayer', () => {
  it('should show selection box for single shape', () => {
    const container = document.createElement('div');
    const store = createMockStore({
      shapes: [createMockShape('shape-1')],
      selectedShapeIds: ['shape-1'],
    });
    
    const selectionLayer = new SelectionLayer({ container, store });
    
    const selectionBox = container.querySelector('.selection-box');
    expect(selectionBox).toBeTruthy();
    expect(selectionBox?.getAttribute('data-shape-id')).toBe('shape-1');
  });
  
  it('should show resize handles', () => {
    const container = document.createElement('div');
    const store = createMockStore({
      shapes: [createMockShape('shape-1')],
      selectedShapeIds: ['shape-1'],
    });
    
    const selectionLayer = new SelectionLayer({ container, store });
    
    const handles = container.querySelectorAll('.resize-handle');
    expect(handles.length).toBe(8);
  });
});
```

### çµ±åˆãƒ†ã‚¹ãƒˆ

```typescript
// tests/integration/ToolManager.test.ts
describe('ToolManager Integration', () => {
  it('should switch between tools', () => {
    const canvas = new WhiteboardCanvas(container);
    
    canvas.setActiveTool('rectangle');
    expect(canvas.getActiveTool()?.id).toBe('rectangle');
    
    canvas.setActiveTool('select');
    expect(canvas.getActiveTool()?.id).toBe('select');
  });
  
  it('should create shape with rectangle tool', async () => {
    const canvas = new WhiteboardCanvas(container);
    canvas.setActiveTool('rectangle');
    
    // ãƒ‰ãƒ©ãƒƒã‚°ã§çŸ©å½¢ã‚’æç”»
    await simulateDrag(container, { x: 100, y: 100 }, { x: 200, y: 200 });
    
    const shapes = store.getState().shapes;
    expect(shapes).toHaveLength(1);
    expect(shapes[0].type).toBe('rectangle');
  });
});
```

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®äº‹é …

### 1. ã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒã‚¦ãƒ³ã‚¹

```typescript
class DebouncedToolManager extends ToolManager {
  private moveDebounceTimer?: number;
  
  protected handlePointerMove(event: PointerEvent): void {
    if (this.moveDebounceTimer) {
      cancelAnimationFrame(this.moveDebounceTimer);
    }
    
    this.moveDebounceTimer = requestAnimationFrame(() => {
      super.handlePointerMove(event);
    });
  }
}
```

### 2. é¸æŠãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æœ€é©åŒ–

```typescript
class OptimizedSelectionLayer extends SelectionLayer {
  private updateScheduled = false;
  
  protected scheduleUpdate(): void {
    if (this.updateScheduled) return;
    
    this.updateScheduled = true;
    requestAnimationFrame(() => {
      this.updateSelection();
      this.updateScheduled = false;
    });
  }
}
```

## âœ… ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### å®Ÿè£…æ™‚ã®ç¢ºèªäº‹é …

- [ ] å„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒç‹¬ç«‹ã—ã¦ãƒ†ã‚¹ãƒˆå¯èƒ½
- [ ] ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ãŒé©åˆ‡ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã•ã‚Œã‚‹
- [ ] ãƒ‡ãƒ¼ã‚¿å±æ€§ãŒä¸€è²«ã—ã¦è¨­å®šã•ã‚Œã‚‹
- [ ] E2Eãƒ†ã‚¹ãƒˆã¨ã®äº’æ›æ€§ãŒä¿ãŸã‚Œã‚‹
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒæœ€é©åŒ–ã•ã‚Œã¦ã„ã‚‹

### çµ±åˆæ™‚ã®ç¢ºèªäº‹é …

- [ ] ãƒ„ãƒ¼ãƒ«åˆ‡ã‚Šæ›¿ãˆãŒæ­£ã—ãå‹•ä½œã™ã‚‹
- [ ] é¸æŠçŠ¶æ…‹ãŒè¦–è¦šçš„ã«åæ˜ ã•ã‚Œã‚‹
- [ ] ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ãŒæ­£ã—ãè¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ã‚¹ãƒˆã‚¢ã®çŠ¶æ…‹ãŒåŒæœŸã•ã‚Œã‚‹
- [ ] ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãŒãªã„

ã“ã‚Œã‚‰ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã«å¾“ã†ã“ã¨ã§ã€æ–°ã—ã„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«çµ±åˆã§ãã¾ã™ã€‚